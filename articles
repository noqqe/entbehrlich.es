#!/usr/bin/env python3.4
"""
Blog maintainance script for
    entbehrlich.es
to post to twitter and release new posts
"""
# -*- coding: utf-8 -*-

import os
import random as rnd
import time
import textwrap
import datetime
import warnings
import subprocess
from urllib.parse import urlparse
import urllib.request

import PIL
from PIL import Image
import click
import nltk
import git
import requests
import wikipedia
import twitter
import feedparser
import xmltodict
from dateutil.parser import parse

# Environment variables
project_home = os.getcwd()
posts_home = project_home + "/content/post/"
images_home = project_home + "/static/images/"
hugocmd = "/home/noqqe/.go/bin/hugo"
rsynccmd = "/usr/local/bin/rsync -avi --delete public/ aax:/var/www/htdocs/entbehrlich.es/"
feedurl = project_home + "/public/index.xml"
editor = "/usr/local/bin/vim"

ftpuser = 'entbehrliches'
ftppass = 'Nikainahm1Oh'

# Commons API
commonsapi = "https://tools.wmflabs.org/magnus-toolserver/commonsapi.php?image="

# Twitter credentials
con_key = "aWoryvyvjQqV2aCDOyg6YJCJi"
con_secret = "A8JhSSKM0996vjKV8NwKi8dvR2ApCfuRb6M8rRav6ctojhQcRk"
access_token = "723558748581683201-QYcFL4pFqHxgflEjcxkeIE5BfMEI6JM"
access_token_secret = "Dd8oGmYhXpMfGcFF3HdsqKO8iD2q902uuHFs7cUZI3HbI"

# Logging
def log(msg, serv="debug"):
    """
    Logging to terminal
    :msg: str
    :serv: str (serverity)
    :returns: bool
    """

    colors = {
        "debug": "white",
        "info": "green",
        "warning": "yellow",
        "error": "red",
    }

    d = datetime.datetime.now().strftime('%H:%M:%S ')
    click.secho(d + msg, fg=colors[serv])

def gen_article_image(images, debug):
    """
    :images: list
    :returns: str
    """

    final_image = None
    author = None
    for image in images:

        # skip if not part of commons
        if not "/commons/" in image:
            continue

        # skip if its an svg
        if ".svg" in image:
            continue

        # build api url
        url = urlparse(image)
        fname = os.path.basename(url.path)
        fname = commonsapi + fname + "&meta"
        log("Fetching image meta informations from %s" % fname, "debug")

        # query api and get dict of api items
        try:
            xml = requests.get(fname).text
            commons = xmltodict.parse(xml)
            c = commons["response"]["file"]
        except:
            continue

        # filter pictures that are too small
        if float(c["width"]) < 540:
            continue

        # get crappy license meta data
        try:
            license = commons["response"]["licenses"]["license"]["name"]
        except TypeError:
            try:
                license = commons["response"]["licenses"]["license"][0]["name"]
            except TypeError:
                continue

        # check if its a friendly license
        if not "CC-BY" in license and not "CC-PD" in license:
            continue

        # fetch the author of the picture
        try:
            author = c["author"]
        except KeyError:
            continue

        title = c["title"].replace('File:', '')
        log("Found CC-BY Picture \"%s\" from %s" % (title, c["uploader"]), "debug")
        final_image = download_image(url=c["urls"]["file"], fname=title, debug=False)
        resize_image(title)
        break

    return final_image, author

# Article generators
def gen_article_meta(title, date, tags, image, imageauthor):
    """
    Make a blog post header like
    ---
    title: foo
    date: bar
    draft: false
    image: /images/foo.jpg
    imageauthor: h0nk
    tags:
    - foo
    - bar
    ---

    :title: str
    :date: str
    :tags: list
    :image: str
    :returns: str
    """
    head = "---\n"
    n = "\n"

    header = head + "title: " + title + n
    header = header + "date: " + date + n
    header = header + "draft: true" + n

    if image is not None:
        header = header + "image: " + image + n
        header = header + "imageauthor: " + imageauthor + n

    header = header + "tags: "
    for tag in tags:
        header = header + n + "- " + tag.replace("Kategorie:", '')

    header = header + n + head + n
    return header

def gen_article_quote(summary, title, url):
    """
    Takes the wiki summary and builds

    > lorem ipsum
    >
    > Quelle: [Lorem Impsum](https://...)

    :summary: str (wiki summary from wikilib)
    :title: str (generated title for the post being used as link text)
    :url: str (article url)
    :returns: str (full multiline quote)
    """

    # shortcut for newline
    n = '\n'

    # first sentence of the article and quote it for markdown
    if len(summary) >= 350:
        summary = nltk.tokenize.sent_tokenize(summary)[0]

    summary = textwrap.wrap(summary, 78)

    # start with a single quote for markdown
    fmtsummary = ""
    for x in summary:
        fmtsummary = fmtsummary + textwrap.indent(x, '> ') + n

    # add source and proper link to quote
    quote = fmtsummary + '>' + n + '> Quelle: ' + gen_markdown_link(url=url, txt=title)

    return quote

def gen_article_thanks(thanks):
    """
    Takes a twitter username and adds a friendly thank
    you at the end of the post

    :thanks: str (twitter username)
    :returns: str
    """
    if thanks is not None:
        log("Thanks to %s was added to article" % thanks, "info")
        txt = "Danke an %s!" % gen_markdown_link(url="https://twitter.com/" + thanks, txt=thanks)
    else:
        txt = ""

    return txt

def gen_markdown_link(url, txt=None):
    """
    Build url for blogpost with urlencoding
    like this [http://foo.bar/baz](http://foo.bar.baz)
    :url: str (link target)
    :txt: str (link text)
    :returns: str
    """

    if txt is not None:
        mdurl = '[' + txt + ']'
    else:
        cont = url.replace("https://", "")
        cont = url.replace("http://", "")
        mdurl = '[' + cont + ']'

    mdurl = mdurl + '(' + url + ')'

    return mdurl

# Sync and deploying functions
def build(hugocmd):
    """
    Executes hugo to build the latest build of the blog

    :hugocmd: str (command and args)
    :returns: bool
    """
    log("Compiling blog...", "debug")

    status, output = subprocess.getstatusoutput(hugocmd)

    if status == 0:
        log("Blog compiled successfully", "info")
        return True
    else:
        log("Blog compiling failed: \n %s" % output, "error")
        return False

def deploy(rsynccmd):
    """
    Uses rsync to deploy the build to the serving http server

    :rsynccmd: str (command and args)
    :returns: bool
    """
    status, output = subprocess.getstatusoutput(rsynccmd)
    log("Deploying blog...", "debug")

    if status == 0:
        log("Blog deployment successful", "info")
        return True
    else:
        log("Blog deployment failed: \n %s" % output, "error")
        return False

def publish(post):
    """
    Pick draft post, update date and draft to false

    :post: str (filename of the post)
    :returns: bool
    """

    t = datetime.datetime.now()
    t = t.replace(microsecond=0)
    t = t.isoformat()
    path = posts_home + post

    try:
        open(path)
    except IOError:
        log("No such file %s" % path, "error")
        return False

    if not 'draft: true' in open(path).read():
        log("Article %s was already release. Updating publish date" % post, "debug")

    # because FUCK YOU HARD FILEINPUT!
    subprocess.getstatusoutput('sed -i \'s#draft: true#draft: false#\' %s' % path)
    subprocess.getstatusoutput('sed -i \'s#^date: .*#date: %s#\' %s' % (t, path))

    log("Modified %s to draft=false and date %s" % (post, t), "debug")

    return True

def commit(filename, path=posts_home):
    """
    Commit a file in git
    :filename: str (filename of the post)
    :path: str (path)
    :returns: bool
    """

    try:
        repo = git.Repo(project_home)
        repo.git.add(path + filename)
        repo.git.commit(m=filename)
        log("%s committed in git" % filename, "info")
        return True
    except:
        log("Post %s could not be committed" % filename, "error")
        return False

def push():
    """
    Syncs the repo with the serverside repo.
    :returns: bool
    """

    try:
        repo = git.Repo(project_home)
        repo.git.push()
        log("Pushed current state to repository", "info")
        return True
    except:
        log("Failed to push current state to repository" % post, "error")
        return False

def pull():
    """
    Syncs the serverside repo with the local repo
    :returns: bool
    """

    try:
        repo = git.Repo(project_home)
        repo.git.pull()
        log("Pulled content from remote repository", "info")
        return True
    except:
        log("Failed to pull state from remote repository" % post, "error")
        return False



def tweet(feedurl):
    """
    Tweet latest blogpost from rss feed
    :feedurl: str (http uri)
    :returns: bool
    """

    feed = feedparser.parse(feedurl)
    title = feed['entries'][0]['title']
    link = feed['entries'][0]['link']

    message = title + " " + link

    auth = twitter.OAuth(
        consumer_key=con_key,
        consumer_secret=con_secret,
        token=access_token,
        token_secret=access_token_secret,
	)

    try:
        t = twitter.Twitter(auth=auth)
        t.statuses.update(status=message)
        log("Tweeted \"%s\"" % message, "info")
        return True
    except:
        log("Could not send tweet. Check debugging", "error")
        return False

def download_image(url, fname, debug):
    """
    Downloads an image and places it to the right
    :url: str
    :returns: str path to picture
    """
    log("Downloading %s from %s" % (fname, url), "debug")

    if not debug:
        urllib.request.urlretrieve(url, images_home + fname)
        log("Downloaded %s from %s" % (fname, url), "info")

    src = "/images/" + fname
    return src

def resize_image(fname):
    """
    resize a downloaded picture from images/ homedir
    :returns: bool
    """

    basewidth = 540
    fpath = images_home + fname
    img = Image.open(fpath)
    wpercent = (basewidth/float(img.size[0]))
    hsize = int((float(img.size[1])*float(wpercent)))
    log("Resizing image %s to %sx%s" % (fname, basewidth, hsize), "debug")
    img = img.resize((basewidth,hsize), PIL.Image.ANTIALIAS)
    img.save(fpath)
    commit(fname, images_home)
    return True

# CLI Commands

@click.group()
def cli():
    """ cli command group """
    pass

@cli.command(short_help="Create a new post")
@click.argument('url')
@click.option('date', '-d', '--date', default=str(datetime.datetime.now()))
@click.option('thanks', '-t', '--thanks', default=None)
@click.option('debug', '--debug', is_flag=True, default=False)
def new(url, date, thanks, debug):
    """
    \b
    Create new post.
    Fetches content from wikipedia url
    Creates article header
    Creates quote from article with reference
    Adds thank you at the end of the article
    """

    # needed in further building of article
    origurl = url

    # newline shortcut
    n = "\n"

    # find wikipedia link
    url = urlparse(url)
    lang = url.netloc.split('.')[0]
    title = url.path.split('/')[2].replace('-', ' ').replace('_', ' ')
    filename = title.replace(' ', '-').replace('---', '-').replace(')', '').replace('(', '') + '.md'

    # set lang and title, fetch wikipedia article
    try:
        wikipedia.set_lang(lang)
        wiki = wikipedia.page(title)
        tags = wiki.categories
        images = wiki.images
        summary = wiki.summary
        log("Fetched article \"%s\" from wikipedia (%s)" % (title, lang), "info")
    except wikipedia.exceptions.DisambiguationError as e:
        log(e, "error")
        return False

    t = parse(date)
    t = t.replace(hour=14, minute=0, microsecond=0)
    t = t.isoformat()

    # fetch images
    image, imageauthor = gen_article_image(images, debug)

    # generate header for article
    header = gen_article_meta(title=title, date=t, tags=tags, image=image, imageauthor=imageauthor)

    # generate quote for article
    quote = gen_article_quote(summary=summary, title=title, url=origurl)

    # generate thank you section for posted article
    thanks = gen_article_thanks(thanks)


    # put all the content together
    text = \
        header + \
        n + n + \
        quote + \
        n + n + \
        thanks

    # if debug is on, just print and quit the function.
    # no edit, no commit, no file written
    if debug:
        log("Only showing generated post on stdout", "debug")
        log(n + text, "debug")
        return True

    # write markdown to the document
    path = posts_home + filename
    with open(path, "w") as f:
        f.write(text)
        f.close()

    log("Created post in path " + path, "info")

    # edit file
    subprocess.call([editor, path])

    # pull from repo
    pull()

    # commit to local repo
    commit(filename, posts_home)

    # push to repo
    push()

    return True

@cli.command(short_help="Show current drafts")
@click.option('allposts', '--all', '-a',  is_flag=True)
def queue(allposts):
    """
    \b
    Shows all unpublished posts. Can also show all posts ever using -a
    """

    posts = os.listdir(posts_home)
    if not allposts:
        log("All unpublished posts:", "debug")
        for post in posts:
            if 'draft: true' in open(posts_home + post).read():
                log(" * " + post, "debug")
    else:
        log("All posts:", "debug")
        for post in posts:
            log(" * " + post, "debug")

    return True

@cli.command(short_help="Publish a post")
@click.argument('post', required=False, default=None)
def release(post):
    """
    \b
    Releases a post to the website
    * removes draft status from post
    * commit post in git
    * build hugo
    * deploy to webserver
    * tweet about it

    """

    # if no specific post given, use a random one
    if post is None:
        log("Picking random post...", "debug")
        posts = os.listdir(posts_home)

        while True:
            post = rnd.choice(posts)
            if 'draft: true' in open(posts_home + post).read():
                log("Picked %s" % post, "info")
                break

    # pull from remote repo
    if not pull():
        return False

    # remove draft
    if not publish(post):
        return False

    # commit git changes
    if not commit(post, posts_home):
        return False

    # push git changes
    if not push():
        return False

    # build blog
    if not build(hugocmd):
        return False

    # deploy to server
    if not deploy(rsynccmd):
        return False

    # tweet the new post
    if not tweet(feedurl):
        return False

    return True

@cli.command(short_help="Build and deploy to entbehrlich.es")
def redeploy():
    """
    \b
    Redeploy means that no new content will be published.
    The blog will be build and rsynced to the server
    """

    # build blog
    build(hugocmd)

    # build deploy to server
    deploy(rsynccmd)

    return True

@cli.command(short_help="Edit an already written article")
@click.argument('post', required=True)
def reedit(post):
    """
    Things happen. Sometimes I need to reedit an article.
    """

    # get changes
    pull()

    # edit file
    path = posts_home + post
    subprocess.call([editor, path])

    # commit to local repo
    commit(post, posts_home)

    # push changes
    push()

    return True

@cli.command(short_help="Live recently update articles from Wikipedia")
def inspiration():
    """
    Lookup some new/recently edited articles as inspirations.
    """
    wiki_changes_api = 'https://de.wikipedia.org/w/api.php?action=query&list=recentchanges&format=json&rctype=edit|new&rclimit=1'
    oldid = ""

    try:
        while True:

            # query edits from wikipedia
            r = requests.get(wiki_changes_api).json()
            edit = r["query"]["recentchanges"][0]
            title = edit["title"]

            # some filters
            if "Benutzer:" in title \
                or "Diskussion:" in title \
                or "Wikipedia:" in title \
                or "Kategorie:" in title:
                continue

            # if not seen before, show to user
            if oldid != edit["pageid"]:
                log(title + " -- https://de.wikipedia.org/wiki/?curid=" + str(edit["pageid"]), "debug")
                oldid = edit["pageid"]

            time.sleep(2)
    except KeyboardInterrupt:
        log("End...")
        return True

@cli.command(short_help="Get 20 random articles from Wikipedia")
def random():
    """
    Get some random articles from wikipedia
    """
    wikipedia.set_lang("de")
    for w in wikipedia.random(20):
        try:
            page = wikipedia.page(w)
            log(page.title + " -- " + page.url, "debug")
        except (wikipedia.exceptions.DisambiguationError, wikipedia.exceptions.PageError):
            pass

    return True

# Call wrapper to cli commands
if __name__ == '__main__':
    cli()
